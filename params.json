{"name":"GPmat","tagline":"Matlab implementations of Gaussian processes and other machine learning tools.","body":"GPmat\r\n=====\r\n\r\nMatlab implementations of Gaussian processes and other machine learning tools.\r\n\r\n\r\nGP\r\n==\r\n\r\n### Version 0.136\r\n\r\n\r\nChanges to gpReadFromFID for compatibility with C++ code.\r\n\r\n#### Version 0.135\r\n\r\nModifications by Carl Henrik Ek for compatability with the SGPLVM toolbox.\r\n\r\n#### Version 0.134\r\n\r\nUpdates to allow deconstruction of model files when writing to disk (gpWriteResult, gpLoadResult, gpDeconstruct, gpReconstruct).\r\n\r\n#### Version 0.133\r\n\r\nUpdates for running a GPLVM/GP using the data's inner product matrix for Interspeech synthesis demos.\r\n\r\n#### Version 0.132\r\n\r\nExamples transfered from oxford toolbox, variational approximation from Titsias added as an option with 'dtcvar'.\r\n\r\n#### Version 0.131\r\n\r\nChanges to allow compatibility with SGPLVM and NCCA toolboxes.\r\n\r\n#### Version 0.13\r\n\r\nChanges to allow more flexibility in optimisation of beta.\r\n\r\n#### Version 0.12\r\n\r\nVarious minor changes for enabling back constraints in hierarchical\r\nGP-LVM models.\r\n\r\n#### Version 0.11\r\n\r\nChanges include the use of the optimiDefaultConstraint('positive') to\r\nobtain the function to constrain beta to be positive (which now\r\nreturns 'exp' rather than 'negLogLogit' which was previously the\r\ndefault). Similarly default optimiser is now given by a command in\r\noptimiDefaultOptimiser.\r\n\r\n#### Version 0.1\r\n\r\nThe first version which is spun out of the FGPLVM toolbox. The\r\ncorresponding FGPLVM toolbox is 0.15.\r\n\r\n\r\nRelease 0.1 splits away the Gaussian process section of the FGPLVM\r\ntoolbox into this separate toolbox.\r\n\r\n## Other GP related software\r\n\r\nThe GP-LVM C++ software is available from <a\r\nhref=\"/~neill/gplvmcpp/\">here</a>.\r\n\r\nThe IVM C++ software is available from <a\r\nhref=\"/~neill/ivmcpp/\">here</a>.\r\n\r\nThe MATLAB IVM toolbox is available here <a\r\nhref=\"/~neill/ivm/\">here</a>.\r\n\r\nThe original MATLAB GP-LVM toolbox is available here <a\r\nhref=\"/~neill/gplvm/\">here</a>.\r\n\r\n\r\n## Examples\r\n\r\n\r\n### Functions from Gaussians\r\n\r\nThis example shows how points which look like they come from a\r\nfunction to be sampled from a Gaussian distribution. The sample is 25\r\ndimensional and is from a Gaussian with a particular covariance.\r\n\r\n```matlab\r\n>> demGpSample\r\n```\r\n\r\n<center><img src=\"./html/gpSample.png\" width =\"50%\"><img\r\nsrc=\"./html/gpCovariance.png\" width =\"50%\"><br> <i>Left</i> A single, 25\r\ndimensional, sample from a Gaussian distribution. <i>Right</i> the\r\ncovariance matrix of the Gaussian distribution..  </center>\r\n\r\n\r\n### Joint Distribution over two Variables\r\n\r\nGaussian processes are about conditioning a Gaussian distribution\r\non the training data to make the test predictions. To illustrate this\r\nprocess, we can look at the joint distribution over two variables.\r\n\r\n```matlab\r\n>> demGpCov2D([1 2])\r\n```\r\n\r\nGives the joint distribution for <i>f</i><sub>1</sub> and\r\n<i>f</i><sub>2</sub>. The plots show the joint distributions as well\r\nas the conditional for <i>f</i><sub>2</sub> given\r\n<i>f</i><sub>1</sub>.\r\n\r\n<center><img src=\"./html/demGpCov2D1_2_3.png\" Width =\"50%\"><img\r\nsrc=\"./html/demGpCov2D1_5_3.png\" width =\"50%\"><br> <i>Left</i> Blue line is\r\ncontour of joint distribution over the variables <i>f</i><sub>1</sub>\r\nand <i>f</i><sub>2</sub>. Green line indicates an observation of\r\n<i>f</i><sub>1</sub>. Red line is conditional distribution of\r\n<i>f</i><sub>2</sub> given <i>f</i><sub>1</sub>. <i>Right</i> Similar\r\nfor <i>f</i><sub>1</sub> and <i>f</i><sub>5</sub>.  </center>\r\n\r\n\r\n\r\n### Different Samples from Gaussian Processes\r\n\r\nA script is provided which samples from a Gaussian process with the\r\nprovided covariance function.\r\n\r\n```matlab\r\n>> gpSample('rbf', 10, [1 1], [-3 3], 1e5)\r\n```\r\n\r\nwill give 10 samples from an RBF covariance function with a\r\nparameter vector given by [1 1] (inverse width 1, variance 1) across\r\nthe range -3 to 3 on the <i>x</i>-axis. The random seed will be set to\r\n1e5.\r\n\r\n```matlab\r\n>> gpSample('rbf', 10, [16 1], [-3 3], 1e5)\r\n```\r\n\r\nis similar, but the inverse width is now set to 16 (length scale 0.25).\r\n\r\n<center><img\r\nsrc=\"./html/gpSampleRbfSamples10Seed100000InverseWidth1Variance1.png\" width\r\n=\"50%\"><img\r\nsrc=\"./html/gpSampleRbfSamples10Seed100000InverseWidth16Variance1.png\" width\r\n=\"50%\"><br> <i>Left</i> samples from an RBF style covariance function\r\nwith length scale 1. <i>Right</i> samples from an RBF style covariance\r\nfunction with length scale 0.25.  </center>\r\n\r\nOther covariance functions can be sampled, an interesting one is\r\nthe MLP covariance which is non stationary and can produce point\r\nsymmetric functions,\r\n\r\n\r\n```matlab\r\n>> gpSample('mlp', 10, [100 100 1], [-1 1], 1e5)\r\n```\r\n\r\ngives 10 samples from the MLP covariance function where the &quot;bias\r\nvariance&quot; is 100 (basis functions are centered around the origin\r\nwith standard deviation of 10) and the &quot;weight variance&quot; is\r\n100.\r\n\r\n```matlab\r\n>> gpSample('mlp', 10, [100 1e-16 1], [-1 1], 1e5)\r\n```\r\n\r\ngives 10 samples from the MLP covariance function where the &quot;bias\r\nvariance&quot; is approximately zero (basis functions are placed on\r\nthe origin) and the &quot;weight variance&quot; is 100.\r\n\r\n<center><img\r\nsrc=\"./html/gpSampleMlpSamples10Seed100000WeightVariance100BiasVariance100Variance1.png\"\r\nwidth =\"50%\"><img\r\nsrc=\"./html/gpSampleMlpSamples10Seed100000WeightVariance100BiasVariance1e-16Variance1.png\"\r\nwidth =\"50%\"><br> <i>Left</i> samples from an MLP style covariance\r\nfunction with bias and weight variances set to 100. <i>Right</i>\r\nsamples from an MLP style covariance function with weight variance 100\r\nand bias variance approximately zero.  </center>\r\n\r\n\r\n### Posterior Samples\r\n\r\nGaussian processes are non-parametric models. They are specified by their covariance function and a mean function. When combined with data observations a posterior Gaussian process is induced. The demos below show samples from that posterior.\r\n\r\n```matlab\r\n>>  gpPosteriorSample('rbf', 5, [1 1], [-3 3], 1e5)\r\n```\r\n\r\nand \r\n\r\n```matlab\r\n>>  gpPosteriorSample('rbf', 5, [16 1], [-3 3], 1e5)\r\n```\r\n\r\n<center><img\r\nsrc=\"./html/gpPosteriorSampleRbfSamples5Seed100000InverseWidth1Variance1bw.png\" width\r\n=\"50%\"><img\r\nsrc=\"./html/gpPosteriorSampleRbfSamples5Seed100000InverseWidth16Variance1bw.png\" width\r\n=\"50%\"><br> <i>Left</i> samples from the posterior induced by an RBF style covariance function\r\nwith length scale 1 and 5 &quot;training&quot; data points taken from a sine wave. <i>Right</i> Similar but for a length scale of 0.25.  </center>\r\n\r\n\r\n\r\n\r\n\r\n### Simple Interpolation Demo\r\n\r\n\r\nThis simple demonstration plots, consecutively, an increasing\r\nnumber of data points, followed by an interpolated fit through the\r\ndata points using a Gaussian process. This is a noiseless system, and\r\nthe data is sampled from a GP with a known covariance function. The\r\ncurve is then recovered with minimal uncertainty after only nine data\r\npoints are included. The code is run with\r\n\r\n```matlab\r\n>> demInterpolation\r\n```\r\n\r\n<center><img src=\"./html/demInterpolation3.png\" width =\"50%\"><img\r\nsrc=\"./html/demInterpolation4.png\" width =\"50%\"><br>\r\n\r\nGaussian process prediction <i>left</i> after two points with a new\r\ndata point sampled <i>right</i> after the new data point is included\r\nin the prediction.<br> \r\n\r\n<img src=\"./html/demInterpolation7.png\" width\r\n=\"50%\"><img src=\"./html/demInterpolation8.png\" width =\"50%\"><br>\r\n\r\nGaussian process prediction <i>left</i> after five points with a four\r\nnew data point sampled <i>right</i> after all nine data points are\r\nincluded.<br> </center>\r\n\r\n### Simple Regression Demo\r\n\r\nThe regression demo very much follows the format of the\r\ninterpolation demo. Here the difference is that the data is sampled\r\nwith noise. Fitting a model with noise means that the regression will\r\nnot necessarily pass right through each data point.\r\n\r\nThe code is run with\r\n\r\n```matlab\r\n>> demRegression\r\n```\r\n\r\n\r\n<center><img src=\"./html/demRegression3.png\" width =\"50%\"><img\r\nsrc=\"./html/demRegression4.png\" width =\"50%\"><br>\r\n\r\nGaussian process prediction <i>left</i> after two points with a new\r\ndata point sampled <i>right</i> after the new data point is included\r\nin the prediction.<br> <img src=\"./html/demRegression7.png\" width =\"50%\"><img\r\nsrc=\"./html/demRegression8.png\" width =\"50%\"><br>\r\n\r\nGaussian process prediction <i>left</i> after five points with a four\r\nnew data point sampled <i>right</i> after all nine data points are\r\nincluded.<br> </center>\r\n\r\n### Optimizing Hyper Parameters\r\n\r\nOne of the advantages of Gaussian processes over pure kernel\r\ninterpretations of regression is the ability to select the hyper\r\nparameters of the kernel automatically. The demo\r\n\r\n```matlab\r\n>> demOptimiseGp\r\n```\r\n\r\nshows a series of plots of a Gaussian process with different length\r\nscales fitted to six data points. For each plot there is a\r\ncorresponding plot of the log likelihood. The log likelihood peaks for\r\na length scale equal to 1. This was the length scale used to generate\r\nthe data.\r\n\r\n<center><img src=\"./html/demOptimiseGp1.png\" width =\"33%\"><img\r\nsrc=\"./html/demOptimiseGp3.png\" width =\"33%\"><img src=\"./html/demOptimiseGp5.png\"\r\nwidth =\"33%\"><br><img src=\"./html/demOptimiseGp7.png\" width =\"33%\"><img\r\nsrc=\"./html/demOptimiseGp9.png\" width =\"33%\"><img src=\"./html/demOptimiseGp11.png\"\r\nwidth =\"33%\"><br><img src=\"./html/demOptimiseGp13.png\" width =\"33%\"><img\r\nsrc=\"./html/demOptimiseGp15.png\" width =\"33%\"><img src=\"./html/demOptimiseGp17.png\"\r\nwidth =\"33%\"><br>From top left to bottom right, Gaussian process\r\nregression applied to the data with an increasing length scale. The\r\nlength scales used were 0.05, 0.1, 0.25, 0.5, 1, 2, 4, 8 and\r\n16.<br><img src=\"./html/demOptimiseGp18.png\" width =\"50%\"><br>Log-log plot of\r\nthe log likelihood of the data against the length scales. The log\r\nlikelihood is shown as a solid line. The log likelihood is made up of\r\na data fit term (the quadratic form) shown by a dashed line and a\r\ncomplexity term (the log determinant) shown by a dotted line. The data\r\nfit is larger for short length scales, the complexity is larger for\r\nlong length scales. The combination leads to a maximum around the true\r\nlength scale value of 1.</center>\r\n\r\n### Regression over Motion Capture Markers\r\n\r\nAs a simple example of regression for real data we consider a motion capture data set. The data is <a href=\"http://accad.osu.edu/research/mocap/mocap_data.htm\">from Ohio State University</a>. In the example script we perform Gaussian process regression with time as the input and the x,y,z position of the marker attached to the left ankle. To demonstrate the behavior of the model when the marker is lost, we remove data from This code can be run with\r\n\r\n```matlab \r\n>> demStickGp1 \r\n``` \r\n\r\nThe code will optimize hyper parameters and show plots of the posterior process through the training data and the missing test points.\r\n\r\nThe result of the script is given in the plot below.  \r\n\r\n<center><img src=\"./html/demStickGp1Out1.png\" width\r\n=\"30%\"> <img src=\"./html/demStickGp1Out2.png\" width\r\n=\"30%\"> <img src=\"./html/demStickGp1Out3.png\" width\r\n=\"30%\"><br> Gaussian process regression through the x (left), y (middle) and z (right) position of the left ankle. Training data is shown as black spots, test points removed to simulate a lost marker are shown as circles, posterior mean\r\nprediction is shown as a black line and two standard deviations are\r\ngiven as grey shading.</center>\r\n\r\nNotice how the error bars are tight except in the region where the training data is missing and in the region where the training data disappears.\r\n\r\n### Sparse Pseudo-input Gaussian Processes\r\n\r\nThe sparse approximation used in this toolbox is based on the\r\nSparse Pseudo-input Gaussian Process model described by <a\r\nhref=\"http://ml.sheffield.ac.uk/~neil/cgi-bin/publications/bibpage.cgi?keyName=Snelson:pseudo05&printAbstract=1\">Snelson\r\nand Ghahramani</a>. Also provided are the extensions suggested by <a\r\nhref=\"http://ml.sheffield.ac.uk/~neil/cgi-bin/publications/bibpage.cgi?keyName=Quinonero:unifying05\">Qui&ntilde;onero-Candela\r\nand Rasmussen</a>. They provide a unifying terminology for describing\r\nthese approximations which we shall use in what follows.\r\n\r\nThere are three demos provided for Gaussian process regression in\r\n1-D. They each use a different form of likelihood approximation. The\r\nfirst demonstration uses the &quot;projected latent variable&quot;\r\napproach first described by <a\r\nhref=\"http://ml.sheffield.ac.uk/~neil/cgi-bin/publications/bibpage.cgi?keyName=Csato:sparse02&printAbstract=1\">Csato\r\nand Opper</a> and later used by <a\r\nhref=\"http://ml.sheffield.ac.uk/~neil/cgi-bin/publications/bibpage.cgi?keyName=Seeger:fast03&printAbstract=1\">Seeger\r\n<i>et al.</i></a>. In the terminology of Qui&ntilde;onero-Candela and\r\nRasmussen (QR-terminology) this is known as the &quot;deterministic\r\ntraining conditional&quot; (DTC) approximation.\r\n\r\nTo use this approximation the following script can be run.\r\n\r\n```matlab \r\n>> demSpgp1dGp1 \r\n``` \r\n\r\nThe result of the script is\r\ngiven in the plot below.  \r\n\r\n<center><img src=\"./html/demSpgp1dGp1.png\" width\r\n=\"50%\"><br> Gaussian process using the DTC approximation with nine\r\ninducing variables. Data is shown as black spots, posterior mean\r\nprediction is shown as a black line and two standard deviations are\r\ngiven as grey shading.</center>\r\n\r\nThe improved approximation suggested by Snelson and Ghahramani, in\r\nQR-terminology this is known as the fully independent training\r\nconditional (FITC). To try this approximation run the following script\r\n\r\n```matlab \r\n>> demSpgp1dGp2 \r\n```\r\n\r\nThe result of the script is given on the left of the plot below.\r\n\r\n<center><img src=\"./html/demSpgp1dGp2.png\" width=\"49%\"><img\r\nsrc=\"./html/demSpgp1dGp3.png\" width=\"49%\"><br>\r\n\r\n<i>Left</i>: Gaussian process using the FITC approximation with nine\r\ninducing variables. Data is shown as black spots, posterior mean\r\nprediction is shown as a black line and two standard deviations are\r\ngiven as grey shading. <i>Right</i>: Similar but for the PITC\r\napproximation, again with nine inducing variables.</center>\r\n\r\nAt the <a href=\"http://www.dcs.shef.ac.uk/ml/gprt/\">Sheffield\r\nGaussian Process Round Table</a> Lehel Csato pointed out that the\r\nBayesian Committee Machine of <a\r\nhref=\"http://ml.sheffield.ac.uk/~neil/cgi-bin/publications/bibpage.cgi?group=bcm&printAbstract=1\">Schwaighofer\r\nand Tresp</a> can also be viewed within the same framework. This idea\r\nis formalised in <a\r\nhref=\"http://ml.sheffield.ac.uk/~neil/cgi-bin/publications/bibpage.cgi?keyName=Quinonero:unifying05&printAbstract=1\">Qui&ntilde;onero-Candela\r\nand Rasmussen's</a> review. This approximation is known as the\r\n&quot;partially independent training conditional&quot; (PITC) in\r\nQR-terminology. To try this approximation run the following script\r\n\r\n```matlab\r\n>> demSpgp1dGp3\r\n```\r\n\r\nThe result of the script is given on the right of the plot above.\r\n\r\nFinally we can compare these results to the result from the full\r\nGaussian process on the data with the correct hyper-parameters. To do\r\nthis the following script can be run.\r\n\r\n```matlab\r\n>> demSpgp1dGp4\r\n```\r\n\r\nThe result of the script is given in the plot below.\r\n\r\n<center><img src=\"./html/demSpgp1dGp4.png\" width=\"50%\"><br> Full Gaussian\r\nprocess on the toy data with the correct hyper-parameters. Data is\r\nshown as black spots, posterior mean prediction is shown as a black\r\nline and two standard deviations are given as grey shaded\r\narea.</center>\r\n\r\nGP-LVM\r\n======\r\n\r\nChanges for compatibility with new SGPLVM toolbox by Carl Henrik Ek.\r\n\r\n#### Version 0.162\r\n\r\nAdded new files fgplvmWriteResults fgplvmLoadResults for saving smaller model files.\r\n\r\n#### Version 0.161\r\n\r\nUpdates for running a GPLVM when the inner produce matrix is used\r\n(i.e. dimensionality much greater than data points).  Minor changes to\r\nfix reading of GPLVM files from latest C++ code.\r\n\r\n#### Version 0.16\r\n\r\nIncorporate varational approximation from Michalis in the code. \r\n\r\n#### Version 0.153\r\n\r\nChanges to allow compatibility with SGPLVM and NCCA toolboxes.\r\n\r\n\r\n#### Version 0.152\r\n\r\nBug fix from fgplvmReadFromFID where the values of model.m weren't being computed correctly.\r\n\r\n#### Version 0.151\r\n\r\nIn this version results for the CMU Mocap data set from <a href=\"http://ml.sheffield.ac.uk/~neil/cgi-bin/publications/bibpage.cgi?keyName=Taylor:motion06&printAbstract=1\">Taylor et al.</a> of subject 35 running and walking are included, as well as some minor changes to allow hierarchical GP-LVMs to be used.\r\n\r\n\r\n#### Version 0.15\r\n\r\nThis version splits the Gaussian process portion into a new GP toolbox, the corresponding version is 0.1. Fixed bug in gpDynamicsExpandParam, gpDynamicsExractParam and gpDynamicsLogLikeGradient where 'fixInducing' option  was not being dealt with.\r\n\r\nFixed bug in fgplvmCreate.m where the back constraints were set up, but the latent positions were not being set according to the back constraints in the returned model.\r\n\r\n#### Version 0.141\r\n\r\nChanged GP-LVM default optimiser to scg rather than conjgrad. Added fgplvmOptimiseSequence and dependent files. This is for optimising a test sequence in the latent space, for the case where there are dynamics on the model.\r\n\r\n#### Version 0.14\r\n\r\nCarl Ek implemented multiple sequences in the gpDynamics model used for dynamics in the GPLVM, this was refined and integrated by Neil.\r\n\r\nFixed two bugs in gpPosteriorGradMeanVar which appeared if fitc was used or the scales on the outputs were non-zero. This in turn affected fgplvmOptimisePoint.\r\n\r\nDefault under back constraints switched to not optimise towards a PCA initialisation.\r\n\r\nFixed bug in fgplvmReadFromFID where the old form of fgplvmCreate was being called.\r\n\r\n\r\n#### Version 0.132\r\n\r\nRelease 0.132 includes two speed improvements on the pitc approximation. Thanks to <a href=\"http://www.gatsby.ucl.ac.uk/~snelson/\">Ed Snelson</a> for pointing out that it was unusually slow! New versions of the NDLUTIL and KERN toolbox are also required.\r\n\r\nRelease 0.131 adds the ability to handle missing data and a new reversible dynamics model.\r\n\r\nRelease 0.13 is a (hopefully) fairly stable base release for which several results in forthcoming papers will be created. Additional features are better decompartmentalisation of dynamics models, regularisation of inducing variable's inputs and introduction of fgplvmOptions and gpOptions for setting default options for the models.\r\n\r\nRelease 0.11 is the first release that contains the fully independent training conditional approximation (Snelson and Ghahramani, Quinonero Candela and Rasmussen).  \r\n\r\nRelease 0.1 is a pre-release to make some of the model functionality available. The some of the different approximations (such as fully independent training conditional and partially independent training conditional) are not yet implemented and the dynamics currently has no sparse approximations associated.\r\n\r\nThis toolbox also implements back constraints (joint work with Joaquin Quinonero Candela). The mappings that can be used as back constraints are those described in the MLTOOLS toolbox</a>.\r\n\r\nAlternative GP-LVM implementations from this site:\r\n\r\nThe GP-LVM C++ software is available from <a href=\"https://github.com/SheffieldML/GPc/\">here</a>.\r\n\r\nThe original MATLAB version of the toolbox is available here <a href=\"http://staffwww.dcs.shef.ac.uk/people/N.Lawrence/gplvm/\">here</a>.\r\n\r\n## Examples\r\n\r\n### GP-LVM\r\n\r\nThe three approximations outlined above can be used to speed up learning in the GP-LVM. They have the advantage over the IVM approach taken in the <a href=\"http://staffwww.dcs.shef.ac.uk/people/N.Lawrence/gplvm/\">original GP-LVM toolbox</a> that the algorithm is fully convergent and the final mapping from latent space to data space takes into account all of the data (not just the points in the active set).\r\n\r\nAs well as the new sparse approximation the new toolbox allows the GP-LVM to be run with dynamics as suggested by <a href=\"http://ml.sheffield.ac.uk/~neil/cgi-bin/publications/bibpage.cgi?keyName=Wang:gpdm05&printAbstract=1\">Wang <i>et al.</i></a>.\r\n\r\nFinally, the new toolbox allows the incorporation of `back constraints' in learning. Back constraints force the latent points to be a smooth function of the data points. This means that points that are close in data space are constrained to be close in latent space. For the standard GP-LVM points close in latent space are constrained to be close in data space, but the converse is not true.\r\n\r\nVarious combinations of back constraints and different approximations are used in the exmaples below.\r\n\r\n### Oil Data\r\n\r\nThe 'oil data' is commonly used as a bench mark for visualisation algorithms. For more details on the data see <a href=\"http://staffwww.dcs.shef.ac.uk/people/N.Lawrence/3PhaseData.html\">this page</a>.\r\n\r\nThe <a href=\"https://github.com/SheffieldML/GPc/\">C++ implementation of the GP-LVM</a> has details on training the full GP-LVM with this data set. Here we will consider the three different approximations outlined above.\r\n\r\n#### FITC Approximation\r\n\r\nIn all the examples we give there will be 100 points in the active set. We first considered the FITC approximation. The script `demOilFgplvm1.m` runs the FITC approximation giving the result on the left of the figure shown below.\r\n\r\n<center><img src=\"./html/demOilFgplvm1.png\" width=\"49%\"><img src=\"./html/demOilFgplvm2.png\" width=\"49%\"><br>\r\n<i>Left</i>: GP-LVM on the oil data using the FITC approximation without back constraints. The phases of flow are shown as green circles, red crosses and blue plusses.  One hundred inducing variables are used. <i>Right</i>: Similar but for a back-constrained GP-LVM, the back constraint is provided by a multi-layer perceptron with 15 hidden nodes.</center>\r\n\r\nBack constraints can be added to each of these approximations. In the example on the right we used a back constraint given by a multi-layer perceptron with 15 hidden nodes. This example can be recreated with `demOilFgplvm2.m`.\r\n\r\n#### DTC Approximation\r\n\r\nThe other approximations can also be used, in the figures below we give results from the DTC approximation. The can be recreated using `demOil3.m` and `demOil4.m`.\r\n\r\n<center><img src=\"./html/demOilFgplvm3.png\" width=\"49%\"><img src=\"./html/demOilFgplvm4.png\" width=\"49%\"><br>\r\n<i>Left</i>: GP-LVM on the oil data using the DTC approximation without back constraints. The phases of flow are shown as green circles, red crosses and blue plusses.  One hundred inducing variables are used. <i>Right</i>: Similar but for a back-constrained GP-LVM, the back constraint is provided by a multi-layer perceptron with 15 hidden nodes.</center>\r\n\r\n#### PITC Approximation\r\n\r\nWe also show results using the PITC approximation, these results can be recreated using the scripts `demOilFgplvm5.m` and `demOilFgplvm6.m`.\r\n\r\n<center><img src=\"./html/demOilFgplvm5.png\" width=\"49%\"><img src=\"./html/demOilFgplvm6.png\" width=\"49%\"><br>\r\n<i>Left</i>: GP-LVM on the oil data using the PITC approximation without back constraints. The phases of flow are shown as green circles, red crosses and blue plusses.  One hundred inducing variables are used. <i>Right</i>: Similar but for a back-constrained GP-LVM, the back constraint is provided by a multi-layer perceptron with 15 hidden nodes.</center>\r\n\r\n#### Variational DTC Approximation\r\n\r\nFinally we also show results using the variational DTC approximation of Titsias, these results can be recreated using the scripts `demOilFgplvm7.m` and `demOilFgplvm8.m`.\r\n\r\n<center><img src=\"./html/demOilFgplvm7.png\" width=\"49%\"><img src=\"./html/demOilFgplvm8.png\" width=\"49%\"><br>\r\n<i>Left</i>: GP-LVM on the oil data using the variational DTC approximation without back constraints. The phases of flow are shown as green circles, red crosses and blue plusses.  One hundred inducing variables are used. <i>Right</i>: Similar but for a back-constrained GP-LVM, the back constraint is provided by a multi-layer perceptron with 15 hidden nodes.</center>\r\n\r\n\r\n### Back Constraints and Dynamics\r\n\r\nFirst we will demonstrate the dynamics functionality of the toolbox. We raw x-y-z values from a motion capture data set, the `Figure Run 1` example available <a href=\"http://accad.osu.edu/research/mocap/mocap_data.htm\">from Ohio State University</a>. To run without dynamics use the script:\r\n\r\n```matlab\r\n>> demStickFgplvm1\r\n```\r\n\r\nThe results are given on the left of the figure below.\r\n\r\n<center><img src=\"./html/demStickFgplvm1.png\" width=\"49%\"><br>\r\nGP-LVM on the motion capture data without dynamics in the latent space. </center>\r\n\r\nNotice that the sequence (which is a few strides of a man running) is split into several sub-sequences. These sub-sequences are aligned to the strides of the man. By introducing a dynamics prior, we can force the sequence to link up. Samples from the dynamics prior used are shown in the plot below.\r\n\r\n<center><img src=\"./html/dynamicsSamp1.png\" width=\"49%\"><img src=\"./html/dynamicsSamp2.png\" width=\"49%\"><br>\r\n<img src=\"./html/dynamicsSamp3.png\" width=\"49%\"><img src=\"./html/dynamicsSamp4.png\" width=\"49%\">\r\nSamples from the dynamics prior which is placed over the latent space. This prior has <i>Left</i>: GP-LVM on the motion capture data without dynamics in the latent space. <i>Right</i>: GP-LVM with dynamics. Samples from the dynamics prior used are given in the figure above.</center>\r\n\r\nThis prior is used in the model to obtain the results below,\r\n\r\n```matlab\r\n>> demStickFgplvm2\r\n```\r\n\r\n<center><img src=\"./html/demStickFgplvm2.png\" width=\"49%\"><br>\r\nGP-LVM with dynamics. Samples from the dynamics prior used are given in the figure above.</center>\r\n\r\nNote now the circular form of the latent space. \r\n\r\nBack constraints can also be used to achieve a similar effect,\r\n\r\n```matlab\r\n>> demStickFgplvm3\r\n```\r\n\r\n<center><img src=\"./html/demStickFgplvm3.png\" width=\"49%\"><br>\r\nGP-LVM with back constraints. A RBF kernel mapping was used to form the back constraints with the inverse width set to 1e-4 (<i>i.e.</i>length scale set to 100).</center>\r\n\r\n### Loop Closure in Robotics\r\n\r\nIn on-going work with Dieter Fox and Brian Ferris at the University of Washington we are interested in loop closure for robotic navigation, included as an example is a data set of a robot completing a loop while reading wireless access point signal strengths. To produce a neat track and close the loop it turns out it is necessary to use dynamics and back constraints as seen in the images below. These results can be recreated with `demRobotWireless1.m` through `demRobotWireless4.m`.\r\n\r\n<center><img src=\"./html/demRobotWireless1.png\" width=\"49%\"><img src=\"./html/demRobotWireless2.png\" width=\"49%\"><br>\r\n<img src=\"./html/demRobotWireless3.png\" width=\"49%\"><img src=\"./html/demRobotWireless4.png\" width=\"49%\"><br>\r\nUse of back constraints and dynamics to obtain loop closure in a robot navigation example. <i>Top Left</i>: GP-LVM without back constraints or dynamics, <i>Top right</i>: GP-LVM with back constraints, no dynamics, <i>Bottom Left</i>: GP-LVM with dynamics, no back constraints, <i>Bottom right</i>: GP-LVM with back constraints and dynamics. </center>\r\n\r\n### Vocal Joystick and Vowel Data\r\n\r\nAnother ongoing piece of work with Jeff Bilmes and Jon Malkin involves embedding vowel sounds in a two dimensional space as part of <a href=\"http://ssli.ee.washington.edu/vj\">vocal joystick</a> system. Jon has provided a simple data set of 2,700 examples of different vowels. These are embedded in a two dimensional latent space with and without back constraints.\r\n\r\n<center><img src=\"./html/demVowels2.png\" width=\"49%\"><img src=\"./html/demVowels3.png\" width=\"49%\"><br>\r\n<i>Left</i>: embedding of the vowel data without back constraints, <i>Right</i>: embedding of the vowel data with back constraints. <i>/a/</i> - red cross, <i>/ae/</i> - green circle, <i>/ao/</i> - blue plus, <i>/e/</i> - cyan asterix, <i>/i/</i> - magenta square, <i>/ibar/</i> - yellow diamond, <i>/o/</i> - red down triangle, <i>/schwa/</i> - green up triangle, <i>/u/</i> - blue left triangle.\r\n</center>\r\n\r\n### Larger Human Motion Data Sets\r\n\r\nFor <a href=\"http://ml.sheffield.ac.uk/~neil/cgi-bin/publications/bibpage.cgi?keyName=Lawrence:larger07&printAbstract=1\">an AISTATS paper</a> we recreated an experiment from <a href=\"http://ml.sheffield.ac.uk/~neil/cgi-bin/publications/bibpage.cgi?keyName=Taylor:motion06&printAbstract=1\">Taylor <em>et al.</em>'s NIPS paper</a>. They created a data set from a motion capture data in the <a href=\"http://mocap.cs.cmu.edu\">CMU data base</a> of running and walking. The data set can now be recreated using the <a href=\"/~neill/datasets/\">DATASETS toolbox</a>. We repeated missing data experiments by Taylor et al.. The model learning for these experiments can be recreated with:\r\n\r\n```matlab\r\n>> demCmu35gplvm1\r\n```\r\n\r\nfor the four dimensional latent space, `demCmu35gplvm2` for the three dimensional latent space and `demCmu35gplvm3` for the five dimensional latent space. The test data reconstruction can then be performed for all models with `demCmu35gplvmReconstruct`. Taylor <i>et al.</i>'s nearest neighbour results can be recreated using `demCmu35TaylorNearestNeighbour`.\r\n\r\nData was pre-processed by mapping angles to be between -180 and 180 and scaling the data such that the variance of each dimension was one.\r\nThe quality of the trained model was evaluated using a missing data problem with a test sequence of data. The model was required to fill in either upper body angles or right leg angles. Results for the GP-LVM and nearest neighbour in both scaled space and original angle space are given in the table below.\r\n<center>\r\n<table>\r\n<tr>\r\n<td></td><td align=\"center\">Leg</td><td align=\"center\">Leg</td><td align=\"center\">Body</td><td align=\"center\">Body</td>\r\n</tr>\r\n<tr>\r\n<td></td><td align=\"center\">Cumulative</td><td align=\"center\">RMS</td><td align=\"center\">Cumulative</td><td align=\"center\">RMS</td>\r\n</tr>\r\n<tr>\r\n<td></td><td align=\"center\">Scaled</td><td align=\"center\">Angles</td><td align=\"center\">Scaled</td><td align=\"center\">Angles</td>\r\n</tr>\r\n<tr>\r\n<td>GP-LVM (<i>q</i>=3)</td><td align=\"right\">11.4</td><td align=\"right\">3.40</td><td align=\"right\"><b>16.9</b></td><td align=\"right\"><b>2.49</b></td>\r\n</tr>\r\n<tr>\r\n<td>GP-LVM (<i>q</i>=4)</td><td align=\"right\"><b>9.7</b></td><td align=\"right\"><b>3.38</b></td><td align=\"right\">20.7</td><td align=\"right\">2.72</td>\r\n</tr>\r\n<tr>\r\n<td>GP-LVM (<i>q</i>=5)</td><td align=\"right\">13.4</b></td><td align=\"right\">4.25</td><td align=\"right\">23.4<td align=\"right\">2.78</td>\r\n</tr>\r\n<tr>\r\n<td>Scaled NN</td><td align=\"right\">13.5</b></td><td align=\"right\">4.44</td><td align=\"right\">20.8<td align=\"right\">2.62</td>\r\n</tr>\r\n<tr>\r\n<td>Nearest Neighbour</td><td align=\"right\">14.0</b></td><td align=\"right\">4.11</td><td align=\"right\">30.9<td align=\"right\">3.20</td>\r\n</tr>\r\n</table>\r\n</center>\r\n\r\nThe cumulative scaled error is a recreation of the error reported in Taylor <i>et al.</i> which was the average (across angles) cumulative sum (across time) of the squared errors in the down-scaled (<i>i.e.</i> variance one) space of angles. We also present the root mean squared angle error for each joint which we find to be a little easier to interpret.\r\n\r\nTaylor <i>et al.</i> used a slightly different representation of\r\nthe data set which included the absolute <i>x</i> and <i>z</i>\r\nposition of the root node and rotation around the <i>y</i>-axis. For\r\nthis data set, this information does help, principally because the\r\nsubject seems to start in roughly the same position at the beginning\r\nof each sequence. However, in general absolute position will not help,\r\nso we discarded it in favour of a representation of these values in\r\nterms of differences between frames. Finally Taylor <i>et al.</i>\r\nconcatenated two frames to form each data point for the model. We\r\nchose not to do this as we wanted to test the ability of the Gaussian\r\nprocess dynamics to fully recreate the data set. There results are given in their paper and summarised below.\r\n\r\n<center>\r\n<table>\r\n<tr>\r\n<td></td><td align=\"center\">Leg</td><td align=\"center\">Body</td>\r\n</tr>\r\n<tr>\r\n<td></td><td align=\"center\">Cumulative</td><td align=\"center\">Cumulative</td>\r\n</tr>\r\n<tr>\r\n<td></td><td align=\"center\">Scaled</td><td align=\"center\">Scaled</td>\r\n</tr>\r\n<td>Binary Latent Variable Model</td><td align=\"right\"><b>11.7</b></td><td align=\"right\"><b>8.8</b></td>\r\n</tr>\r\n<tr>\r\n<td>Scaled NN</td><td align=\"right\">22.2</td><td align=\"right\">20.5</td>\r\n</tr>\r\n</table>\r\n</center>\r\nFinally we show a plot of reconstructions of two of the angles in the data.\r\n\r\n<center><img src=\"./html/demCmu35gplvmLegReconstruct1_8.png\" width=\"50%\"><img src=\"./html/demCmu35gplvmLegReconstruct1_9.png\" width=\"50%\"></center>\r\nPrediction for first two angles of the right hip joint (see plots in <a href=\"http://ml.sheffield.ac.uk/~neil/cgi-bin/publications/bibpage.cgi?keyName=Taylor:motion06&printAbstract=1\">Taylor <i>et al.</i></a> for comparison). Dotted line is nearest neighour in scaled space, dashed line is GP-LVM with 4-D latent space.</center>\r\n\r\n\r\nIVM\r\n===\r\n\r\n\r\n## Examples\r\n\r\n## `demClassification1`\r\n\r\nThe first example given is `demClassification1` which is a simple classification data set, where only one direction of the input is relevant in determining the decision boundary. An ARD MLP kernel is used in combination with a linear kernel. The ARD parameters in the linear and MLP kernel are constrained to be the same by the line:\r\n\r\n```matlab\r\n% Constrain the ARD parameters in the MLP and linear kernels to be the same.\r\n\r\nmodel.kern = cmpndTieParameters(model.kern, {[4, 7], [5, 8]});\r\n```\r\n\r\nThe resulting classification is shown below.\r\n\r\n<center><img src=\"./html/demClassificationOne1.png\"><br>\r\n\r\nDecision boundary from the `demClassification1.m` example. Postive class is red circles, negative class green crosses and active points are yellow dots. Decision boundary shown in red, contours at 0.25 and 0.75 probability shown in blue.</center>\r\n\r\n\r\n\r\n\r\n\r\n## `demClassification2`\r\n\r\nThe second example attempts to learn a Gaussian process give data that is sampled from a Gaussian process. The code is `demClassification2`. The underlying Gaussian process is based on an RBF kernel with variance inverse width 10. The IVM learns an inverse width of 15 and gives the classification is shown below.\r\n\r\n<center><img src=\"./html/demClassificationTwo2.png\"><br>\r\n\r\nDecision boundary from the `demClassification2.m` example. Postive class is red circles, negative class green crosses and active points are yellow dots. Decision boundary shown in red, contours at 0.25 and 0.75 probability shown in blue.</center>\r\n\r\n\r\n\r\n## `demClassification3`\r\n\r\nThis example is similar to `demClassification2`, only now there is a null category region in the data (a region of low data density between the classes). The example is for comparison with the null category noise model.\r\n\r\n\r\n\r\n<center><img src=\"./html/demClassificationThree3.png\"><br>\r\n\r\nDecision boundary from the `demClassification3.m` example. Postive class is red circles, negative class green crosses and active points are yellow dots. Decision boundary shown in red, contours at 0.25 and 0.75 probability shown in blue.</center>\r\n\r\n\r\n\r\n## `demOrdered1`\r\n\r\nIn this example the ordered categorical noise model is used (ordinal regression). The data is a simple data set for which a linear one dimensional model suffices. The IVM is given a combination of an RBF and linear kernel with ARD.For the ordered categorical case there are several parameters associated with the noise model (in particular the category widths), these are learnt too. The model learns that the system is linear and only one direction is important. The resulting classification is given below.\r\n\r\n\r\n\r\n<center><img src=\"./html/demOrderedOne1.png\"><br>\r\n\r\nDecision boundary from the `demOrdered1.m` example. Class 0 - red cross, Class 1 - green circles, Class 2 - blue crosses, Class 3 - cyan asterisks, Class 4 - pink squares, Class 5 - yellow diamonds. Class 6 - red triangles. Active points are yellow dots, note that because the kernel is linear by now the most informative points tend to be at the extrema. Decision boundaries shown in red, contours at 0.25 and 0.75 probability shown in blue.</center>\r\n\r\n\r\n\r\n## `demOrdered2`\r\n\r\nAnother example with the ordered categorical noise model, here the data is radial, the categories being along the radius of a circle. The IVM is given a combination of an RBF and linear kernel with ARD. Again there are several parameters associated with the noise model, and these are learnt using `ivmOptimiseNoise`. The resulting classification is given below.\r\n\r\n\r\n\r\n<center><img src=\"./html/demOrderedTwo2.png\"><br>\r\n\r\nDecision boundary from the `demOrdered1.m` example. Class 0 - red cross, Class 1 - green circles, Class 2 - blue crosses, Class 3 - cyan asterisks, Class 4 - pink squares, Class 5 - yellow diamonds. Class 6 - red triangles. Active points are yellow dots, note that because the kernel is linear by now the most informative points tend to be at the extrema. Decision boundaries shown in red, contours at 0.25 and 0.75 probability shown in blue.</center>\r\n\r\n\r\n\r\n\r\n\r\n## `demRegression1`\r\n\r\nIn this example the Gaussian noise model is used (standard regression). The data is sampled from a Gaussian process, only one input dimension is important. The IVM is given a combination of an RBF and linear kernel with ARD. The resulting regression is given below.\r\n\r\n\r\n\r\n<center><img src=\"./html/demRegressionOne1.png\"><br>\r\n\r\nRegression from the example `demRegression1.m`. Targets are red dots and active points are yellow dots.</center>\r\n\r\n\r\n\r\n## `demRegression2`\r\n\r\nA second example with Gaussian noise, sampled from a Gaussian process, but this time with differing length scales.\r\n\r\n\r\n\r\n<center><img src=\"./html/demRegressionTwo2.png\"><br>\r\n\r\nRegression from the example `demRegression2.m`. Targets are red dots and active points are yellow dots.</center>\r\n\r\n\r\n\r\n## Benchmark Data Sets\r\n\r\n\r\n\r\nThe function `ivmGunnarData` allows you to test the IVM on Gunnar Raetsch's benchmark data sets. Download the data sets, <a href=\"http://ida.first.fraunhofer.de/projects/bench/benchmarks.htm\">from here</a> and expand the ringnorm data set into '$DATASETSDIRECTORY/gunnar/ringnorm'. Then run the following script.\r\n\r\n\r\n\r\n\r\n\r\n```matlab\r\n\r\n>>ivmGunnarData('ringnorm', 1, {'rbf', 'bias', 'white'}, 1, 100)\r\n\r\n...\r\n\r\n\r\n\r\nFinal model:\r\n\r\nIVM Model:\r\n\r\n Noise Model:\r\n\r\n  Probit bias on process 1: 0.0439\r\n\r\n  Probit Sigma2: 0.0000\r\n\r\n Kernel:\r\n\r\n  Compound kernel:\r\n\r\n    RBF inverse width: 0.0866 (length scale 3.3984)\r\n\r\n    RBF variance: 1.2350\r\n\r\n    Bias Variance: 8.2589\r\n\r\n    White Noise Variance: 0.0000\r\n\r\nTest Error 0.0183\r\n\r\nModel likelihood -56.7120\r\n\r\n```\r\n\r\n\r\n\r\nYou can try any of the data sets by replacing ringnorm with the relevant data set (note that they don't all work with only 100 active points inas in the example above, for example the 'banana' data set needs 200 active points to get a reasonable result,\r\n\r\n\r\n\r\n```matlab\r\n\r\n>> ivmGunnarData('banana', 1, {'rbf', 'bias', 'white'}, 1, 200)\r\n\r\n...\r\n\r\nFinal model:\r\n\r\nIVM Model:\r\n\r\n Noise Model:\r\n\r\n  Probit bias on process 1: 0.1067\r\n\r\n  Probit Sigma2: 0.0000\r\n\r\n Kernel:\r\n\r\n  Compound kernel:\r\n\r\n    RBF inverse width: 1.6411 (length scale 0.7806)\r\n\r\n    RBF variance: 0.2438\r\n\r\n    Bias Variance: 0.0000\r\n\r\n    White Noise Variance: 0.0148\r\n\r\nTest Error 0.1129\r\n\r\nModel likelihood 175.3588\r\n\r\n```\r\n\r\n\r\n\r\n\r\n\r\n<center><img src=\"./html/demBanana1.png\"><br>\r\n\r\nDecision boundary from the banana example. Postive class is red circles, negative class green crosses and active points are yellow dots. Decision boundary shown in red, contours at 0.25 and 0.75 probability shown in blue.</center>\r\n\r\n\r\n\r\n## Null Category Noise Model\r\n\r\n\r\n\r\n## Examples\r\n\r\n\r\n\r\nThe toy data example in the papers can be recreated using:\r\n\r\n\r\n\r\n```matlab\r\n\r\n>> demUnlabelled1\r\n\r\n```\r\n\r\n\r\n\r\nand leads to the decision boundary given below. A standard IVM based classifier can be run on the data using\r\n\r\n\r\n\r\n```matlab\r\n\r\n>> demUnlabelled2\r\n\r\n```\r\n\r\n\r\n\r\n<center><img src=\"./html/demUnlabelledOne1.png\"><img src=\"./html/demUnlabelledOne2.png\"><br>\r\n\r\nThe null category noise model run on toy data. <i>Top</i>: using the null category, the true nature of the decision boundary is recovered. <i>Bottom</i>: the standard IVM, does not recover the true decision boundary.</center>\r\n\r\n\r\n\r\nThe other USPS digit classification example given in the NIPS paper can be re-run with:\r\n\r\n\r\n\r\n```matlab\r\n\r\n>> demThreeFive\r\n\r\n```\r\n\r\n\r\n\r\nBe aware that this code can take some time to run. The results, in the form of averaged area under ROC curve against probability of missing label, can be plotted using\r\n\r\n\r\n\r\n\r\n\r\n```matlab\r\n\r\n>> demThreeFiveResults\r\n\r\n```\r\n\r\n<center><image src=\"./html/demThreeFive.png\"><br>Plot of average area under ROC curve against probability of label being present. The red line is the standard IVM based classifier, the blue dotted line is the null category noise model based classifier, the green dash-dot line is the a normal SVM and the mauve dashed line is the transductive SVM.\r\n\r\n</center>\r\n\r\n\r\nMLTOOLS\r\n=======\r\n\r\nFix to re-enable HGPLVM visualization.\r\n\r\n#### Version 0.138\r\n\r\nMinor tweak of model write result and model load result to allow specification of the data loading function.\r\n\r\n#### Version 0.137\r\n\r\nRelease for release of VARGPLVM with dynamics.\r\n\r\n#### Version 0.136\r\n\r\nMinor mods.\r\n\r\n#### Version 0.135\r\n\r\nMinor mods.\r\n\r\n#### Version 0.134\r\n\r\nAdded pmvu model.\r\n\r\n#### Version 0.133\r\n\r\nAdded functionality for writing model files using modelDeconstruct commands to keep written files smaller.\r\n\r\n#### Version 0.132\r\n\r\nAdd click visualise functionality for LVM visualization, Laplacian eigenmaps and wrapper for MVU. \r\n\r\n#### Version 0.1311\r\n\r\nMinor change to lvmScatterPlot to fix bug caused when minimum values were positive.\r\n\r\n#### Version 0.131\r\n\r\nMinor changes to toolbox to fix reading in of C++ code.\r\n\r\n#### Version 0.13\r\n\r\nAdded paramNameRegularExpressionLookup.m to regular expression match a parameter name in a model and return the associated indices. paramNameReverseLookup.m does the same thing but for the specific parameter name. Also added multimodel type, which allows for multi-task style learning of existing models. Added linear mapping type of model. \r\n\r\n#### Version 0.1291\r\n\r\nChanges to modelOutputGrad.m, modelOut.m, kbrOutputGrad.m, kbrExpandParam.m, modelOptimise.m to allow compatibility with SGPLVM and NCCA toolboxes. Added a preliminary coding of LLE. \r\n\r\nNote that to run the LLE code you will need to download the file &quot;eigs_r11.m&quot;\r\n\r\n#### Version 0.129\r\n\r\nSeveral changes for ICML dimensionality reduction tutorial, including adding density networks and GTM code as well as various latent variable visualisation code such as lvmTwoDPlot and lvmVisualise.\r\n\r\nAdded dnet type model for GTM and density networks. Added various lvm helper files for doing nearest neighbour and plotting results for latent variable models. Added lmvu and mvu embedding wrapper. Added ppca model type. Added output gradients for model out functions (for magnification factor computation in dnet models). Added helpers for reading various models from FID mapmodel, matrix etc.).\r\nAdded rbfOutputGradX and visualisation for spring dampers type.\r\n\r\n\r\n#### Version 0.128\r\n\r\nFixed Viterbi alignment algorithm, thanks to Raquel Urtasun for pointing out the problems with it.\r\n\r\nCarl Henrik Ek added embeddings with maximum variance unfolding (landmark and normal) to the toolbox. Also several files modified by Carl Henrik to allow a single output dimension of a model to be manipulated.\r\n\r\n#### Version 0.127\r\n\r\nMinor modifications including adding file modelAddDynamics to replace fgplvmAddDynamics.\r\n\r\n#### Version 0.126\r\n\r\nModified kbrParamInit to scale alpha weights and biases by number of data. Added 'dynamicsSliderChange' to lvmClassVisualise to allow visulisation of models with 'gpTime' style-dynamics.\r\n\r\n#### Version 0.125\r\n\r\nAdded multimodel for learning multiple indepedent models with shared parameters.\r\n\r\n#### Version 0.124\r\n\r\nAdded periodic RBF network and model gradient checker.\r\n\r\n#### Version 0.123\r\n\r\nMinor release in line with IVM toolbox 0.4.\r\n\r\n#### Version 0.122\r\n\r\nAdded Hessian code for base model type and for MLP. Added Viterbi alignment code, viterbiAlign.\r\n\r\n#### Version 0.121\r\n\r\nVarious minor bug fixes and changes which seem to have gone undocumented.\r\n\r\n#### Version 0.12\r\n\r\nExtended model type to be a generic container module for optimising any model. Added model test for testing a created model. The code is still in a bit of flux though with some design decisions not made and some code untested.\r\n\r\n#### Version 0.111\r\n\r\nFixed bug in kbr where bias parameter fields where still being referred to as b.Also acknowledged the fact that the isomap graph may not be fully connected in isomapEmbed, but don't yet deal with it properly. Finally added lleEmbed.m for wrapping the lle code.\r\n\r\n#### Version 0.11\r\n\r\nUpdated release for operation with FGPLVM toolbox 0.13. Structure of model creation changed and functions of the form modelOptions.m included for setting default options of the various machine learning models.\r\n\r\n#### Version 0.1\r\n\r\nThe first release of the toolbox with various wrappers for NETLAB functions. Also latent variable model visualisation code was moved into this toolbox.\r\n\r\n## Examples\r\n\r\n### LLE\r\n\r\n#### The Swiss Roll\r\n\r\nThe `swiss roll data' is often used to illustrate dimensionality reduction algorithms despite the fact that it is very unrepresentative of real data sets.\r\n\r\nIn the first examples we use 1000 data points to represent the swiss roll,  `demSwissRollLle1.m` and  `demSwissRollLle2.m`.\r\n\r\n<center><img src=\"./html/demSwissRollLle1.png\" width=\"49%\"><img src=\"./html/demSwissRollLle2.png\" width=\"49%\"><br>\r\n<i>Left</i>:  LLE on the swiss roll data using 4 neighbours. <i>Right</i>: LLE on the swiss roll data using 8 neighbours.</center>\r\n\r\nIn the next examples we use 3000 data points to represent the swiss roll,  `demSwissRollFullLle1.m` and  `demSwissRollFullLle2.m`.\r\n\r\n\r\n<center><img src=\"./html/demSwissRollFullLle1.png\" width=\"49%\"><img src=\"./html/demSwissRollFullLle2.png\" width=\"49%\"><br>\r\n<i>Left</i>:  LLE on the full swiss roll data using 4 neighbours. <i>Right</i>: LLE on the full swiss roll data using 8 neighbours.</center>\r\n\r\n#### Oil Data\r\n\r\nThe `oil data' is commonly used as a bench mark for visualisation algorithms. For more details on the data see <a href=\"http://staffwww.dcs.shef.ac.uk/people/N.Lawrence/3PhaseData.html\">this page</a>.\r\n\r\nIn these examples we used the 1000 data points from the training data for the oil,  `demOilLle1.m` and  `demOilLle2.m`.\r\n\r\n\r\n<center><img src=\"./html/demOilLle1.png\" width=\"49%\"><img src=\"./html/demOilLle2.png\" width=\"49%\"><br>\r\n<i>Left</i>:  LLE on the oil data using 4 neighbours, 9 errors when using classification by nearest neighbour in the latent space. <i>Right</i>: LLE on the oil data using 8 neighbours, 151 errors when using classification by nearest neighbour in the latent space.</center>\r\n\r\n\r\n","google":"UA-62971049-1","note":"Don't delete this file! It's used internally to help with page regeneration."}