function g = orderedNoiseGradientParam(noise, mu, varsigma, y)

% ORDEREDNOISEGRADIENTPARAM Gradient of the ordered categorical noise model's parameters.

% IVM

D = size(y, 2);
c = 1./sqrt(varsigma);
gnoise.bias = zeros(1, D);
gnoise.widths = zeros(noise.C-2, 1);
gnoise.eta = 0;
for j = 1:D
  % Do lowest category first
  index = find(y(:, j)==0);
  if ~isempty(index)
    mu(index, j) = mu(index, j) + noise.bias(j) ;
    mu(index, j) = mu(index, j).*c(index, j);
    %/~
    % This is the stable way of computing Gaussian/erf
    % gnoise.bias(j) = gnoise.bias(j) - sum(c(index, j)./...
    %     (sqrt(2*pi)...
    %      *(exp(1/2*mu(index, j).^2)...
    %        -.5*erfcx(-sqrt(2)/2*mu(index, j)))));
    %~/
    denom = (cumGaussian(-mu(index, j)) ...
                 + noise.eta/(1-noise.C*noise.eta));
    gnoise.eta = gnoise.eta + sum((-noise.C*cumGaussian(-mu(index,j))+1)./denom);
    gnoise.bias(j) = gnoise.bias(j) ...
        - sum(c(index, j).*ngaussian(mu(index, j)) ...
              ./denom);
  end

  % Intermediate categories
  index = find(y(:, j)>0 & y(:, j) <noise.C-1);
  if ~isempty(index)
    for i = index'
      mu(i, j) = mu(i, j) + noise.bias(j) - sum(noise.widths(1:y(i, j)-1));
    end
    u = mu(index, j).*c(index, j);
    uprime = (mu(index, j) - noise.widths(y(index, j))).*c(index, j);
    denom = (cumGaussian(u) - cumGaussian(uprime) ...
                 + noise.eta/(1-noise.C*noise.eta));
    gnoise.bias(j) = gnoise.bias(j) ...
        + sum(c(index, j) ...
              .*(ngaussian(u) - ngaussian(uprime))...
              ./denom);
    gnoise.eta = gnoise.eta ...
        + sum((-noise.C*(cumGaussian(u) ...
                   - cumGaussian(uprime))+1)./denom);
    for cat = 1:noise.C-2
      
      subIndex = find(y(index, j) == cat);
      if ~isempty(subIndex)
        denom = (cumGaussian(u(subIndex)) ...
                 - cumGaussian(uprime(subIndex)) ...
                 + noise.eta/(1-noise.C*noise.eta));
        addpart = sum(c(index(subIndex), j) ...
                      .*ngaussian(uprime(subIndex)) ...
                      ./denom);
        gnoise.widths(1:cat) = gnoise.widths(1:cat) ...
            + repmat(addpart, cat, 1);
        if(cat > 1)
          addpart = sum(c(index(subIndex), j) ...
                        .*ngaussian(u(subIndex)) ...
                        ./denom);
          gnoise.widths(1:cat-1) = gnoise.widths(1:cat-1) ...
              - repmat(addpart, cat-1, 1);
        end
      end
    end
  end
  
  % Highest category
  index = find(y(:, j) == noise.C-1);
  if ~isempty(index)
    for i = index'
      mu(i, j) = mu(i, j) + noise.bias(j) - sum(noise.widths(1:y(i, j)-1));
    end
    mu(index, j) = mu(index, j).*c(index, j);
    %/~
    % gnoise.bias(j) = gnoise.bias(j) ...
    %     + sum(c(index, j) ...
    %           ./(sqrt(2*pi) ...
    %              *(exp(1/2*mu(index, j).^2) ...
    %                -.5*erfcx(sqrt(2)/2*mu(index, j)))));
    %~/
    denom = (cumGaussian(mu(index, j)) ...
                 + noise.eta/(1-noise.C*noise.eta));
    gnoise.bias(j) = gnoise.bias(j) ...
        + sum(c(index, j).*ngaussian(mu(index, j)) ...
              ./denom);
    gnoise.eta = gnoise.eta ...
        + sum((-noise.C*cumGaussian(mu(index, j))+1)./denom, 1);
    if length(noise.widths > 0)
      %/~
      % addpart = sum(...
      %     c(index, j) ...
      %     ./(sqrt(2*pi) ...
      %        *(exp(1/2*mu(index,j).^2) ...
      %          -.5*erfcx(sqrt(2)/2*mu(index, j)))));
      %~/
      addpart = sum(c(index,j).*ngaussian(mu(index, j)) ...
                    ./(cumGaussian(mu(index, j)) ...
                       + noise.eta/(1-noise.C*noise.eta)));
      gnoise.widths = gnoise.widths ...
          - repmat(addpart, noise.C-2, 1);
    end
  end
end
gnoise.widths = gnoise.widths.*noise.widths;
gnoise.eta = gnoise.eta.*noise.eta;
%gnoise.eta = gnoise.eta.*(noise.eta.*(1-noise.C*noise.eta));
%gnoise.bias = (1gnoise.bias;
g = [gnoise.eta gnoise.bias gnoise.widths(:)'];